//go:generate go run github.com/99designs/gqlgen generatepackage graphimport (	"context"	"fmt"	"service-for-working-with-posts-on-graphql/internal/models"	"sync")// This file will not be regenerated automatically.//// It serves as dependency injection for your app, add any dependencies you require here.type Resolver struct{ Repo Repository }// Comment returns CommentResolver implementation.func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }// Mutation returns MutationResolver implementation.func (r *Resolver) Mutation() MutationResolver {	return &mutationResolver{r, NewSubscriptionResolver()}}// Post returns PostResolver implementation.func (r *Resolver) Post() PostResolver { return &postResolver{r} }// Query returns QueryResolver implementation.func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }// Subscription returns SubscriptionResolver implementation.func (r *Resolver) Subscription() SubscriptionResolver { return NewSubscriptionResolver() }type commentResolver struct{ *Resolver }type mutationResolver struct {	*Resolver	subscriptionResolver *subscriptionResolver}type postResolver struct{ *Resolver }type queryResolver struct{ *Resolver }type Repository interface {	GetPosts(ctx context.Context) ([]*models.Post, error)	GetPostByID(ctx context.Context, postID string) (*models.Post, error)	GetCommentsByPost(ctx context.Context, postID string, page int, pageSize int) ([]*models.Comment, error)	CreatePost(ctx context.Context, title, content string, commentsEnabled bool) (*models.Post, error)	CreateComment(ctx context.Context, postID, parentID, content string) (*models.Comment, error)	GetChildrenComments(ctx context.Context, parentID string) ([]*models.Comment, error)}type subscriptionResolver struct {	commentChannels map[string]chan *models.Comment	mu              sync.Mutex	*Resolver}func NewSubscriptionResolver() *subscriptionResolver {	return &subscriptionResolver{		commentChannels: make(map[string]chan *models.Comment),	}}func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *models.Comment, error) {	r.mu.Lock()	ch := make(chan *models.Comment, 1)	if _, ok := r.commentChannels[postID]; !ok {		r.commentChannels[postID] = ch	} else {		ch = r.commentChannels[postID]	}	r.mu.Unlock()	go func() {		<-ctx.Done()		r.mu.Lock()		close(ch)		delete(r.commentChannels, postID)		r.mu.Unlock()	}()	return ch, nil}func (r *subscriptionResolver) PublishComment(comment *models.Comment) error {	r.mu.Lock()	defer r.mu.Unlock()	if ch, ok := r.commentChannels[comment.PostID]; ok {		select {		case ch <- comment:		default:			return fmt.Errorf("failed to send comment on channel")		}	}	return nil}func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, commentsEnabled bool) (*models.Post, error) {	return r.Repo.CreatePost(ctx, title, content, commentsEnabled)}func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, content string) (*models.Comment, error) {	comment, err := r.Repo.CreateComment(ctx, postID, *parentID, content)	if err != nil {		return nil, fmt.Errorf("failed to create comment: %w", err)	}	if err := r.subscriptionResolver.PublishComment(comment); err != nil {		return nil, fmt.Errorf("failed to publish comment: %w", err)	}	return comment, nil}func (r *queryResolver) Posts(ctx context.Context) ([]*models.Post, error) {	return r.Repo.GetPosts(ctx)}func (r *queryResolver) Post(ctx context.Context, id string) (*models.Post, error) {	return r.Repo.GetPostByID(ctx, id)}func (r *queryResolver) Comments(ctx context.Context, postID string, page *int, size *int) ([]*models.Comment, error) {	defaultPage := -1	defaultSize := -1	if page != nil {		defaultPage = *page	}	if size != nil {		defaultSize = *size	}	return r.Repo.GetCommentsByPost(ctx, postID, defaultPage, defaultSize)}func (r *postResolver) Comments(ctx context.Context, obj *models.Post) ([]*models.Comment, error) {	if obj == nil {		return nil, fmt.Errorf("received nil post")	}	return r.Repo.GetCommentsByPost(ctx, obj.ID, -1, -1)}func (r *commentResolver) Children(ctx context.Context, obj *models.Comment) ([]*models.Comment, error) {	if obj == nil {		return nil, fmt.Errorf("received nil comment")	}	return r.Repo.GetChildrenComments(ctx, obj.ID)}